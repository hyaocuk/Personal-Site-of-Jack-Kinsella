---
layout: post
title: Janki Method - A new way to learn programming 
subtitle: Using spaced repetition systems to learn and retain technical knowledge
author: Jack Kinsella

---

This is a guide to becoming a productive programmer quickly. In his book _Outliers_, Malcolm Gladwell told the world it takes 10,000 hours to master something. Practice three hours a day, and you’ll shine in ten short years. Millions of readers felt inspired since they too could become the next Bill Gates, if only they put in the hours. As the days turned to months we discovered that 10,000 hours is a lot longer than we anticipated. Limitless potential transformed into complacent fantasy about what might have been.  

*I didn’t have 10,000 hours to spare. Neither do you.*

*Janki* method is an attempt to shorten the time needed to learn programming. It grew out of my impatient dream to build an automated web business that would free me financially, geographically and temporally. 

Well-intentioned learners sometimes flop around in the dark, despite abundant smarts and enthusiasm. The main determinant of their eventual ability is brute volume of time expended.  Ten years sounds about right.

You’ve likely read that learning by doing is better than passive reading; that expressing ideas in writing forces understanding; that knowledge needs constant revision to stay fresh; that creativity comes from linking disparate ideas; and that your past mistakes are your strongest lessons. The question then is do you apply this knowledge systematically to your learning efforts.

*Janki Method* (Jack’s Anki Method) is built on the assumption that Malcolm’s 10k can be hastened using an intelligent approach. The key innovation is the application of a spaced repetition flashcard system, Anki, to learning computer science. 

I believe that any intelligent and disciplined reader can achieve proficiency* in a given field of programming area within 12 months of applying Janki method.

I call this the *Janki Challenge*, and I invite you to take part.

_*I define proficiency as the ability to build and manage full stack applications. In my case I choose web development, and full stack here denotes both backend and frontend development. I choose the Rails stack, seeing as it was and continues to be the highly recommended in this category. The stack includes, but is not limited to Ruby, Rails, JavaScript, CSS, Html, Linux, multi-server architectures, asynchronous requests, regular expressions, TDD, VIM, jQuery, refactoring, design patterns, git source control, recursion, and SQL._

h2. Problems With Learning

h2. I don’t remember a single thing from my degree

Have you ever spent a week studying for an exam, only to forget 90% of what you learned within 2 months and everything else within a year. I know I have. 

Forgetting is the key impediment to learning a knowledge intensive skill such as programming. To program effectively you need to remember various languages, solutions, libraries and gotchas. Because technical material can be so abstract and dry, you’ll tend to forget programming knowledge quickly.

<div class="janki-rule">
The first rule of *Janki* reduces forgetfulness:

_“Every time you learn anything new about programming create a question and answer flashcard and add this card to Anki.”_
</div>

Anki is a Spaced Repetition System. Most algorithms make computers efficient; Anki makes you efficient.  Using the minimal number of repetitions necessary for permanent retention, Anki drills flashcards into your long-term memory.

Begin by creating a deck of flashcards called, say, computer science. A deck contains many cards, and each card consists of a question and an answer. You tag these cards with the categories that best describe their contents. For example, one card might be tagged with 'Rails', and another with ‘SQL'. Each card can have numerous tags, something very useful given how technologies overlap.

Over time you will build up a repository of knowledge on programming, cleanly categorized, easily searchable and regularly backed up in the cloud. Keeping a knowledge reference like is useful, but it doesn’t’ do anything to help you keep the knowledge inside your head long term. The key to this is doing your Ankis.
 
Every morning Anki calculates which cards you risk forgetting, and then prompts you to review these cards. On any given day, only a fraction of your deck needs to be revised, so doing your Ankis only takes a few minutes per day. 

For every card you review, Anki shows you the question card, and at first the answer side will be blocked out. Your job is to answer the question in your head and then reveal the answer to check whether you got it right. After answering four buttons appear at the bottom of the screen: “again”, “good”, “easy” and “very easy”.  Assess how easy the card was then press the appropriate button. Based on what you say Anki determines when next to show you that card, so answering honestly is crucial for the algorithm to work.

Do this every day and you will not forget. 

h2. Everyone takes up guitar.

Most people fail to learn programming for the same reason they don’t get good at playing guitar: although they practice hard for the first few weeks, they soon lose motivation, and give up before they start seeing results.

Trying to learn using intense activity over short periods of time is problematic. Your mind needs time to reflect on the new things it learns, so skills like programming take longer to learn than you might estimate. By accepting this reality and using a learning approach that emphasizes incremental daily efforts, you will be less likely to burn out. 

<div class="janki-rule">
The second rule of *Janki* encourages commitment to daily learning:

_“You must use Anki every single day- including weekends and holidays - and commit to doing so indefinitely.”_
</div>

Doing your Ankis must hold the same force of habit as brushing your teeth. You should feel naughty if you miss your daily Ankis.

This rule isn’t as demanding as it might at first seem.  After a few months of practice you will be able do your Ankis in 5-8 minutes. Finding that time shouldn’t be a problem either, since Anki is available on smart-phone, meaning you can review while you walk to work, sit in the bus or have a spare minute at the office. Anki even synchronizes the state of your decks across all your devices, so changes to your desktop deck will be reflected on your other devices. 

h2. Right place. Right time.

Learning out of context is wasteful. Reading a textbook from cover to cover may be interesting, but if those concepts are not relevant to the technical problems you currently face, then you will lack the mental context needed to assimilate that knowledge. Incomplete understanding and wasted effort ensues.

<div class="janki-rule">
The third rule of *Janki* keeps you focused on what is important:

_“Learn in context. Pick a project, and learn only what you need to get it done.”_
</div>

h2. Getting It On

_“I learned everything about sex the hard way – from a book.”_

Like sex, programming is better and more enjoyably mastered through practice. Textbook without practice insulate you from reality.

When you read about programming without trying the code, that knowledge gets represented inside your mind in a form that is incomplete, poorly understood, and difficult to apply in practical situations.

You will fail to notice critical details. Small things, such as the placing of quotations around a parameter to a function, or rules about where whitespace is allowed, seem trivial when you first read about them. These same concepts, however, can be difficult to apply correctly in practice, and will be the source of much frustration and error. It is only by trying the code out that you will really understand the language, techniques, and commands in question. 

<div class="janki-rule">
The fourth rule of *Janki* protects grounds your knowledge in reality:

_“Only add a card to your deck after having tried to use the item of knowledge.”_
</div>

Say you are working on an application powered by an SQL database. To build it you will need to refer to literature on database design and SQL (a query language for selecting records from database tables). As you work on the application you will be exposed to new concepts. Try out each new nugget of knowledge before adding it to your Anki deck. If, for example, you read about how to delete a row in a database table, then you should try deleting an actual row in your database before creating the Anki card detailing that SQL query. 

h2. Mistakes and Emotion: Apathetic error

Our past mistakes serve as excellent memory aides.  This is a major reason why we learn by doing. That said, not all past mistakes are equally effective at teaching us lessons; there is a correlation between the emotional impact of an error and the time that lesson remains in memory. 

Say you make a major mistake. You accidentally push incomplete code to a live server, taking your app down for 12 hours. You panic to fix it, and as the customer complaints flood in you feel stupid and embarrassed. This emotional punishment serves as a strong reminder of your error, and you will be more careful when pushing code to a server in future.

Errors with emotional impact are, thankfully, rare, and you are unlikely to need Anki to learn from these. But what about the rest of the mistakes we make, where the emotional element is diminished or even absent? We may need to make these mistakes many times before eventually learning our lesson. 

Mistake repetition is the number of times you need to commit a particular mistake over a lifetime before learning a permanent lesson. Because mistakes are costly, embarrassing and potentially career threatening, it is sensible to minimize their occurrence. Bosses, customers and co-workers understand a first time mistake, and all but the most unreasonable will forgive you. They will not feel so forgiving the second or third time you get the same thing wrong.

<div class="janki-rule">
The fifth rule of *Janki* method minimizes mistake repetition.

_“Every time you make a mistake carry out a post mortem and try to figure out the lessons in the experience. Think about you would need to know to prevent that mistake from occurring again, and turn this insight into new flashcards.”_
</div>

By applying this rule you substitute real world mistakes with Janki reviews.  You will learn from your mistakes more quickly and without the embarrassment and risk of real world error. 

Ankifying your past failures doesn’t just prevent repetition of the same mistake.  It also helps you understand your domain, since the act of performing a post mortem and examining the underlying causes of your error encourages you to think deeply.  Instead of just creating the cards you need to prevent that particular error, you might immunize yourself against that entire class of error.

Every mistake becomes a learning experience. Messing up still sucks, but you feel a small sense of victory knowing that you’ve just found a way to improve, and you will feel assured by the certainty that you’ll never make that mistake again.

h2. The critical mirror

By following the initial five rules of Janki method you will quickly become proficient at the low level details of programming, the functions names, commands, parameters, and algorithms that form the building blocks of your programs.

As your experience grows you will be faced with bigger questions, such as architectural decisions about the structure of your application, strategies to minimize complexity, processes for managing multiple versions of your code, and striking a balance between performance, code readability and elegance. Answering these questions requires deep knowledge and a wealth of real world experience, and for this reason you must never miss an opportunity to build your understanding and insight of these big picture questions.

<div class="janki-rule">
The sixth rule of *Janki* method encourages regular critical reflection:

_“At the end of every project ask yourself what lessons you learned and what you would do differently if you were to repeat the project with the benefit of hindsight.”_
</div>

After a large project, such as completion of a new app, take some time to reflect. Ask yourself overarching questions, such as:

*	Did I waste time going down any dead ends? Is there anything I could do in future to help me foresee these, and prevent them from happening again?
*	Did I choose the right technologies? Can I come up with a schema to help me make the right choices next time?
*	Did I accurately estimate the time required?
*	Could I have built simpler architecture? Could I have figured this out earlier?

Some of these questions will be difficult to answer because you have to run through alternative answers in your head, thinking about the benefits and tradeoffs of each. This effort is worthwhile since sensible architectural decisions prevent wasted effort. Without active reflection you will be less likely to notice these project level patterns, and so your opportunity to gain this insight will be lost.

h2. The Unkempt Garden

Like a front lawn left idle, your Anki decks can grow ugly. Perhaps one of the programming languages you previously learned has changed dramatically in version 2.0 and now a percentage of your cards are invalid. Perhaps some of your cards are no longer worthy of keeping in periodic review– their usefulness doesn’t justify the cumulative revision time needed. 

As you learn, you will discover simpler way to understand concepts; without updating your cards to reflect these improved paradigms you risk losing these insights forever. You will find you can often replace a group of cards with a single card detailing a higher order concept. 

Sometimes you will see links between cards in your deck. If you update these conceptually linked cards to reflect the connection you notice you create multiple neural paths to the same item of knowledge. If one path were to fail, you could still arrive trigger that knowledge with another route. This is the same mechanism by which mind maps work as a memory aide, and by looking for and noting these connections this you will add a layer of redundancy that insures against forgetting hard-earned programming knowledge.

<div class="janki-rule">
The seventh rule of *Janki* keeps your decks in shape.

_“Delete or modify any incorrect, outdated, difficult to remember, incomplete or unnecessary cards. Update existing cards as improved understanding dawns.”_
</div>

h2. Forgotten Inspiration

Graphic designers, artists, architects and other creatives keep scrapbooks of designs they like. Later, when they are working on project, these books are browsed for inspiration.

As a programmer your primary source of inspiration will be other people’s code. Download open source projects (e.g. on Github:http:www.github.com) and read through the code. Look up parts you don’t understand, and create new cards as necessary. Get and pen and paper and sketch out the paths through the program. What are the inputs, and what happens to these inputs as they moves through the program, and what is output?

By reading code you will be exposed to various styles and of programming and solutions to programming problems. You will see things you like, and lots of things you don’t like. With time you will find your own style. 

<div class="janki-rule">
The eight rule of *Janki* encourages you to use your readings of other people’s code as a source of learning:

_“Read code regularly. If you come across something interesting – be that an algorithm, a hack, or an architectural decision - create a card detailing the technique and when it might be useful.”_
</div>

h2. Janki Method: More Than Just A Memory Aide

My original goal with using Anki to learn to program was to ensure I remembered the things I learned. While it certainly works in this respect, I found that long term use of the *Janki* system had numerous other advantages.

h2. Advantage 1: Program Faster

Knowing thousands of commands saves time otherwise spent looking up reference materials. When faced with a problem you instantly recall previous solutions. When architecting a system on pen and paper dozens of possibilities spring to mind. You will read other people's code quickly and rapidly, certain in your understanding. The closest analogy for this is fluency in a natural language.

Most time spent programming is time spent debugging, that is fixing errors in your code or in the code of other programmers. This is where a deep knowledge of the platform will speed you up the most. Debugging consists chiefly of gathering information. What was the system supposed to do? What data was in the system at the time? What could have went wrong? Frequently a single delinquent line of code can be the cause of a bug that takes down an entire system. The hard part is figuring out which of the thousands of lines of logic caused the issue.

Let’s take an example. Say your program uses 100 functions and 70 of these are built into the language. That means that there were 30 functions defined by the programmers on the project. If you know with confidence the inputs and outputs of the 70 built-in functions, then debugging is simplified, since you will only need to figure out how the 30 custom functions work.  Considering that these custom functions are themselves defined in terms of the built-ins, your . The key here is total certainty about the inputs, outputs, effects, and costs of the built in functions.

Another way Janki method helps you to program faster is when you need to brainstorm solutions to a difficult technical problem. Having so much knowledge at your fingertips lets you design alternatives on paper rapidly, and with hope you will come across a cheeky solution that makes your problem disappear in a non-obvious way. 

You might argue that you will get the same benefits from knowledge gained through years of experience. That’s 100% true, but the argument misses the reason you might use Janki method in the first place: Janki enables you to gain that same knowledge faster, and retain it for longer. If you’ve ever forgotten how to do something after leaving it aside for a few months, then Anki is for you.

h2. Advantage 2: Chunking. 

Skill in a technical field is the product of your intelligence and your knowledge.  Weakness in one can be overshadowed strength in another. Bright yet inexperienced can perform on par with dull yet experienced. 

This point is best illustrated by example. Let’s multiply 130 by 30 using two approaches.

Approach 1: You know that multiplication is repeated addition, and so the problem becomes 130  + 130 + 130... and so on. Applying the rules of addition you arrive at 3900 - eventually. Let’s call intelligence your ability to carry out these individual calculations quickly.

Approach 2: Perhaps you remember that 13 X 3 is 39. You might also know that the commutative and associative properties of multiplication let you simplify 130 X 30 to 10 X 13 X 3 X 10 and finally to 39 X 100, which can be calculated trivially as 3900. Your intelligence, or speed of addition here, is irrelevant since knowledge precluded its application.

In approach 1 the problem was labour intensive since you weren’t able to use knowledge shortcuts. This wasn’t the case in approach 2, where you reasoned using higher order chunks of knowledge, so solving an otherwise lengthy problem in mind. I call this chunking.

Janki method encourages chunking. This was an unexpected benefit, yet ultimately the most useful to me. After six months of daily application you will reason about programming concepts using mental shortcuts equivalent to those used to simplify multiplication in approach 2. Maximize chunking by adding increasingly abstract rules and concepts to your decks, and draw on these when solving problems.

h2. Advantage 3:  Searchable archive of all your programming knowledge

Has your computer ever spat out an error message and although you remember seeing it before, you don't remember how you fixed it? Before I started Janki this happened a lot. 

The first time I saw the issue I would spend half a day solving the problem.  Six months later, when it cropped up again, perhaps in a slightly different form, I'd forgotten how to fix it. Even thought I was vaguely aware of having seen it before, I didn’t know what to do about it.

This felt wasteful and it wasn't acceptable. The Hacker Manifesto demands we only solve a particular problem only once. Luckily method helps you avoid this situation. 

Anki has a search function that lets you find any card containing a particular search term. You can even filter by date or tag. For example you might search through cards created more than 6 months ago tagged with ‘server deployment’. 

After solving a bug you should add some cards to Anki containing the knowledge you need to prevent that bug from occurring again. Better yet, abstract one level and add cards containing the knowledge needed to prevent that class of bugs. Now, whenever you are faced with a bug the second time, all you need to do is search your archives.

h2. Advantage 4:  Not Reinventing The Wheel

Modern programming languages have many algorithms built in, or easily included as parts of core libraries. This is especially true of high-level languages such as Ruby, and Python. You want to sort an array? Array#sort does the trick. 

If you didn’t know the sort function was built in you might write your own sort algorithm. When you do so you risk making mistakes, missing out on low level optimizations, and alienating future users of your code, who might think there was a reason other than ignorance for why you wrote a custom sort algorithm instead of using the built-ins. 

By filling your deck with built-ins from your chosen languages you will be less likely to accidentally implement existing features in a half-assed, bug-prone way.

h2. Appendix

h2. Should I download other people's decks? 

Anki has a searchable database of other people's shared decks. Although there aren’t many for computer science, you might be able to find some and be piece these together as the basis for your deck.

Do not do this. You will add facts to your deck that are of no use to you. Just because something was included in the original decks doesn’t mean it will be valuable to you. Not only that, but you will likely review facts that you do not fully understand, so building a poor foundation.  Furthermore, you will inherit the mistakes of the original author.

Instead you should build your own decks from scratch, drawing from your programming experiences, your readings of other people’s code, textbooks, screen casts, and, most important of all, the review of past mistakes and the analysis of previous projects. By creating your decks in this way, you keep your deck filled with well-understood real world knowledge, phrased and categorized in a way that makes sense to you.

h2. Can I download your deck? 

I don't recommend using other people's decks as the basis for your own, but I understand that seeing a full deck may help you understand more about how the system works. For this reason I've made my deck available for free download on my startup’s website "Oxbridge Notes":http://www.oxbridgenotes.co.uk.

My deck focuses on the Ruby on Rails technology stack, including cards on Ruby and Rails 3.1, the HTTP protocol, the Unix command line, git, CSS, JavaScript, VIM, Rspec, Capybara, TDD, Coffeescript, jQuery, deployment, design patterns, regular expressions, SQL, and refactoring. It's everything I've needed to build, manage and deploy a variety of web apps. This is not a commercial product, so do not expect polish or total accuracy. [Please come back on December 15th]

_All rights reserved. In particular, you are not permitted to upload or host my deck or any part thereof online._

h2. How do I know what knowledge is worthy of Janki and what knowledge isn’t?

When I first began Janki method I was over-zealous in my addition of facts to my decks. In particular, I added stacks of cards for third party code libraries. This turned out to be wasteful since I rarely this knowledge. Technology moves rapidly, and today’s in-vogue libraries become tomorrow’s baggage from the past. I ended up deleting many of these cards after having wastefully committed them to long-term memory.

It's not always easy to distinguish between knowledge worth keeping long term and knowledge only needed short term To help me with the decision I came up with a schema: 

I will only enter a card into my decks if one of the following conditions is met:

a) The fact contains general wisdom about computer science (refactoring, regular expressions, object orientated programming, memory issues and so on).

b) The fact relates to a major technology that's been around for a long time, and one that’s probably here to stay (Linux, Ruby, Javascript, VIM, git, HTML, CSS, SQL)

c) The fact, whilst part of a library that is likely to change, is something I use everyday and something I foresee using for some time. Bonus points if the technology is in high demand, since this equates to higher consulting rates. (Rails, jQuery). 

h2. What are the main keyboard shortcuts I need to know?

You will be reviewing your cards everyday so it helps to speed up this process as much as possible. Keyboard shortcuts help greatly.

For speedy reviews hit <enter> to reveal answers and then evaluate your response with the keys 0,1,2 or 3. 

Command + <backspace> lets you delete a troublesome/incorrect/out of date card. 

Command + E lets you edit a card and <tab> moves you between question and answer panes.

h2. The Janki challenge

Want to learn to program within 12 months, and start building powerful apps? Take the Janki challenge. Download Anki, pick a programming project, and publicly announce to your friends that you’ve committed to learn to program using the Janki method.

_Why public commitment? Public commitment creates social pressure that pushes you to honour your promises to the world. This pressure will see you through the difficult first stages where you will be most tempted to give up._

I believe that if you follow the system exactly as described above, you will learn to program significantly more quickly than you would without a systematic approach.

h2. Other Uses Of Janki

I’m now using Janki method for Spanish, mental models and heuristics, writing and ‘life lessons’ (nuggets of wisdom gained through living). If this post is popular I’ll detail my approach in these areas.

h2. In San Francisco? Let’s hang out.

I'm visiting San Francisco during December 2011, so get in touch if you’d like to meet for a lunch/coffee/beer. I’m interested in talking about your consulting projects, or just chatting about programming, entrepreneurship, making money online, web apps, online marketing and all the usual suspects. Get in touch.




