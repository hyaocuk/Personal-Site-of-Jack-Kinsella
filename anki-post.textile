h2. The JANKI Method 

In May 2010 I began an experiment involving flash cards, spaced-repitition systems, and the Ruby/Rails/Javascript/Linux web stack. The premise was simple: every time I learned anything new technologies, or gained deeper wisdom about programming, I would create a flash card and add it to my spaced-repetition system. Every morning, before starting work, I used ANKI, a spaced-repetition system, to drill those flash cards and push the knowledge into my memory. 

I did this every day since May 2010 and I continue doing so today, Nov 4 2011.  In this essay I explain the methodology I used, the reasoning behind it, and compose my thoughts on the effectiveness of the experiment. 

My goal was to learn to program in a fraction of the time it takes using conventional methods. I called it the JANKI method, 

The JANKI method starts with ANKI, an open source spaced reptition system available for free download. You begin by creating a deck, say "Computer Science" within ANKI. A deck contains many facts, and each fact consists of a question, an answer, and as many tags as you like (e.g. 'rails', 'git', 'coffeescript', 'refactoring'). For example, you might have the following fact:

What linux command lists all running processes?

====================
ps

Tags: linux

Although ANKI can download shared decks, letting you use facts created by others, the JANKI method forbids you to do this because you will diminish your learn. Instead you must create you own decks, drawing from your daily experiences programming, snippets of interest code you read, insightful blog posts that teach you something worth remembering, documentation for libraries you need to know, and, most importantly of all, from mistakes you make. JANKI will become your library of coding knowledge, except it has a fantastic twist. Unlike orderinary notesbooks, you're going to know everything in your JANKI notebook by heart for the rest of your life.

Every morning ANKI computes a list of facts for you to revise. The facts it chooses are the ones you most need to revise that day, and its calculated are based on the Supermemo algorithm. The ultimate goal here is for you to drill the cards an aboslute minimum number of times throughout your life, yet retain permanent memory. You've probably head these figures thrown around before - you should revise 1 day after learning, then a week then a month, then 3 months, then a year and so on. RESEARCH (how many reps in life). The supermemo algorithm optimises the process in two ways. It classifies cards which you frequently get wrong as leeches and removes them from the deck, preventing you from using your time inefficiently on that pesky 2%. It also asks you how well you remember any given fact along a scale that ranges from 0, meaning you forgot, to 3, meaning it was an effortless recall. The amount of time until the next repetition is dependent on how well you remembered any given fact last time, and how many times you had previosuly reviewed a fact. Choose 0 and you'll be drilled the fact a minute later, choose 3 it could be months. Telling Anki how well you remember a fact can be difficult, and the onus is on you to answer truthfully and attempt to calibrate the different eases of recall. 

The hardest part of the JANKI method is not adding or finding facts; nor is it reviewing. The real difficulty is in doing it every day, for months or years on end. The JANKI method stricly requires you drill your cards for ten minutes every morning. . 

h2. Why Use The JANKI Method?

h3. 1. Reduce Repeat Error

The only truly stupidity is repeating your mistakes twice. You must learn. You already know this. What you mightn't have though about is the number of failure reptitions it takes you to figure out why sometthin

Furthermore, constant reminder of past errors will cause you to start seeing patterns and classes of mistakes, and you will form a new mental schema of understanding.

h3. 2. Retain Memory of Unused Tools

Have you ever learned a technology, switch to something else for a few months, then come back to the original technology having forgotten close to everything you were supposed to know? I have, repeatedly. I've heard that your brain never really forgets anything, and so that knowledge is supposed to reside somewhere deep inside , but for my use case as a professional, that knowledge is no longer with me and so I need to relearn it. This is a massive waste of time.

One of the key premises to Spaced Repetition Systems, like ANKI, is that knowledge entered into the system and regaularly reviewed will enver leave your memory. I've foudn this claim to be true and if quizzed on the contents of my 5500 card ANKI deck I'm confident I can recall 95% accurately. 

h3. 3. Program Faster

Will having a complete picture of the API in your head make you a faster programmer? Absolutely. You'll save a ton of time you'd otherwise spend re-referring to documentaiton and other reference material. You'll read other people's code as fluently as natural language, and you'll spend your days in the console. Is this the main way the JANKI method increases your productivity? 

Absolutely not.  As I developed the JANKI method I noticed that it helped me program faster for different reasons. Having an in depth knowledge of APIs within your mind helps you most in debugging. Debugging is the act of isolating the problematic line of code and identifying why the problem occurred, the creating a fix that doesn't upset the rest of the code. Having a total undestanding of built-in fucntions and their uses means you only have to look up the custom function to figure out the debugging.

Another way JANKI methods helps you program faster is brainstorming alternatives. An effect I noticed with ANKI generally is that is reduces your recall time. The knowledge is literally at your fingertips (I found this especially when using ANKI with Spanish vocabulary. I could think of words instantly, whereas without ANKI it took strain). Say your boss asks your what the possible solutions are to a hard technical problem. Having so much knowledge at your fingertips lets you design alternatives on paper rapidly, realisticaly thinking through and evaluating the consequences. If you know what types a function expects, what it returns and where it can be used, then you can practically code in your head.

Yes, you might say that you would get the same benefits from deep knowledge of APIs gained through years of experience. That's true but it misses the point of the JANKI method - you'll gain that knowledge far more rapidly and retain it for much longer using ANKI.

h3. 4. Design Away From Your Machine

h3. 5. Inspiration

The thought collision theory of creativity says we create new ideas by combining two old ideas together. Due to how ANKI requires you to review your cards, the facts are essentially jumbled - both in their order and chronolically. I frequently found that cycling through my cards in the morning would set off the spark in my head I needed to solve the problem of the hour. 

h3. 6. Build a deeper understanding of your domain 

As my use of ANKI grew I began to refactor my decks. I'd see that collections of previous cards could be summed up a single higher level rule. I'd notice relationships between functions in different programming languages and scribble a note on a card to help aid memory.

h3. 7. Have a Definitive Searchable Reference of All Your Programming Knowledge

Have you ever had a nasty bug pop up and have vague memories of having seen it before, yet you don't remember exactly how you fixed it? Before I started using ANKI this happenend to me frequently. I would spend half a day solving the bug, forget about it, then six months later I'd face it again. This wasn't acceptable - I wanted to only ahave to solve a particular problem once. Luckily the JANKI method enables you to do this. ANKI has a built in search where you find any fact containing a particular word. You can even filter by date or tags. After every nasty bug you should add a few cards to ANKI containing the knolwedge you need to prevent that bug from occurring again. Better yet abstract one level and add a card containing the knowledge needed to prevent that class of bugs from occurring again.

h3. 8. Feel Like You Are Making Progress

Let's face it. Technology sometimes makes you feel like you are in a rut; there's always more to learn. There's always a stack of books you want to read and learn from. Sometimes you feel like you are at the bottom of a hill. Anki makes you feel better about yourself. You browse through your deck and see the thousands of lessons you've learned. You see the variety of technologies you've learned. You see yourself, months or years ago, typing in those facts. Anki encourages you to sit back and admire the hard work you've put in.

On another level there is something satisying about working on a goal everyday. By reviewing your cards daily you are maintaining your skillset and knowledge, spending perhaps only 5 minutse of your day. You are doing something to sharpen and improve your skills. Like running every day you see results build up day-by-day.

h3. 9. Impress Interviews

So you didn't study CS at Stanford. Problem? For risk-averse companies it is. How do you convince them that despite being self taught you skill have the skills they want? Showing them 5500 flash cards in their technology stack will prove beyond doubt that you know what you are doing.

h2. Objections to the JANKI method 

I've introduced the JANKI method to a few friends and I usually hear the same objections. I'll address each of these below:

h3. 1. The best way to learn something is by doing

I'd like to separate the idea of learning by doing into two components: discovering, and learning from mistakes.

Discovery is unearthing the hidden gaps in your knowledge. You read a book on Javascript, feel confident you know it, only to hen find out that the code you write from memory doesn't work. What happening here is that there you you gaps in your knowledge traceable to you having only seen the knowledge in a sterile book environment instead of having to apply it in real world situations. It is for this reason that it is vital to learn by doing - people cannot be expected to learn in sufficienlty accurate detail just by reading. For this reason I also recommend that you to only add cards to ANKI after trying the code out first, for example in IRB.

The second way of learning by doing is learning from mistakes. You make a major mistake, perhaps pushing unfinished code to your live server. Your mistake costs your company and you remain scarred. The emotional punishment you receive serves as a strong memory aid and it's unlikely you'll need ANKI to learn from these major mistakes. Where ANKI is useful is for lesser errors, where the emotional element is diminished. I've found that it's only after these mistakes happen 3 times that I learn not to make the mistake again. The JANKI method reduces the number of mistake repititions needed for you to learn. If it happens once in the real world, and then you make an ANKI card that goes into regular review, then ANKI reviews will subsitute for real world errors. In short you will learn from your mistakes much more quickly. Not only this but act of recording your mistakes and trying to discern lessons from them will make you a more critical and aware programmer.

h3. 2. I don't have time.

ANKI requires your time in two ways. Firstly you will need to enter facts into ANKI, recording your mistakes as they happen. Secondly you will need to review your cards - the day you create them, a week later, a month after that, three months after that, a year after that, and so on. There is a cost to placing facts in your long term memory.

To this I counter two things. You will save time in the long run through increased programming speed, improved domain understanding, and superiod debugging and architechuture skills. Having a searchable repository of useful APIS and fixes for past bugs may save many hours of time. And, most of all, continuous review of your knolwedge ensures your hard-earned skills do not go to waste. If you are serious about building software, and foresee yourself doing this for at least the medium term future, using the JANKI method is one of the greatest investments you can make in yourself. Given the money people are paying for Rails expertise.

h3. 3. Knowing lots of facts or APIS doesn't make you a better coder.

This was a major concern for me when I initially began my experiment. The limiting factor to your coding productiviity surely isn't your need to consult documentaiton once in a while is it? Yea I might have 30 minutes a day in documentation look-ups and context switching, but that's no biggy right?

What I've learned is that knowing the APIs gives subtler, but far more important advantages:

# If you use a high level language like Ruby many algorithms are already baked into the language. You want to sort an array? Array#sort does the trick. By rolling your own sort algorithm you risk making mistakes, miss out on binary level optimisations, and alienate future users of your code, who might think there was a reason you wrote a custom algorithm instead of using the built ins. By filling your ANKI deck with built-ins from your chosen languages you will only extend the language instead of reinvent it's features.

# Debugging becomes dramatically simpler. Imagine you are debugging a third party library. The code will be filled with a combination of their custom functions and built in fucntions. You will need to figure out what their custom functions do by referencing their documentation, carrying out experiments, or using the debugger. If you recognize all the built-in fucntions, and know precisiely what their expected input values are and what their output values are, you will be able to pinpoint errors much more quickly. The key is total confidence in your knowledge of what the built-ins do, since that means you only have to fiure out what their custom functions do.

# Chunking. Your ability is determined by the application of your intelligence and the use of the lessons you learned through your experience. These two can be substituted to some extent. If you are highly intelligent you might be will perform above what's expected for your experience level. If you have a great deal of experience you will peform above what your intelligence level would dictate. Let me prove this point to you. Intelligence is the application of logic to knowledge so as to generate new knowledge. What's 13 * 3? You apply a few pieces of knowledge, namely that multiplation is repeated addition, and the rules of addition to arrive at the answer 39. Or maybe you didn't. Mabye you already remember that 13*3 is 39. In which case you arrived at the same answer more quickly. Taking it a step further what's 130 * 30? Using intelligence alone this becomes complex. But how can we simplify the problem using knowledge? I know that:
a) 13 * 3 = 39
b) Multiplicaiotn is communitive. Thus 130 * 30 = 13 * 3 * 100
c) x * 100 = 100x

Using these points of knowledge the calcuation becomes simple: 100 (130) = 13000

Using ANKI to reinforce your knowledge brings similar spped advantages in programming. By building a reposititoy of knowledge you will think in higher order chunks and solve difficult problems with ease using powerful heuristics.

h3. 4. APIS and Libraries change and so your hard earned knowledge will become obsolete.

This can be an issue, depending on how you use the ANKI. When I first began the JANKI method I was over-zelous in my addition of facts to my decks. I made cards for thir party libraries I rarely used, such as formtastic, shoulda, and so on. I would turn README's into documenation out of habit. This turned out to be wasteful since the in-vogue library would change every 6 months. I ended up deleting many of these cards.

The problem you will face is to distinguish between knowledge worth keeping long term, and knowledge you don't need (perhaps a cheat sheet would do in these circumstances). I've found that certain areas have proven to be valuable: linux, refactoring, design patterns, git, regular expressions, ruby, object orientated programming principels, javascript, http protocol, sql, css, html, vim commands, rails, and jquery methods. I noticed some patterns in what proves to be useful knowledge:
a) It's a technology that's been around for a long time, and it probably here to stay (VIM, linux)
b) It's general wisdom about computer science (refactorign, regular expressions, object orientated programming)
c) It's something that whilst new or a library, is in everyday use and will foreseeably be so for some time (rails, git). 

I'm sure that one day I'll be repalcing my rails cards with the next-big-thing but I justifiy the continued presence of Rails cards in my deck by the size of the library, it's financail value to employers, and the value of having cards about *a web framework* since many of the concepts and terminology will be useful in future work. 



h2. Download My Deck

Whether you want to build your own deck, use someone else's or do a combination of the two is up to you. Personally I found it useful to view the flash card decks of other programmers, with one caveat: I would try out every function, or piece of knowledge within that deck before committing it. Also I would suspend any cards you don't think will be useful to you - there's no point in maintaining unnecessary knowledge.

My deck is available for download at my startup's "website":http://www.oxbridgenotes.co.uk. The deck deals with ruby and rails 3.1 in detail, and includes sections on everything from design patterns, to refactoring, to the HTTP protocol, CSS, javascript, VIM, rspec, capybara, coffeescript, jquery, deployment issues. It's everything I've needed to know to build, manage and deploy a variety of apps using the Rails stack. Topics are tagged carefully, and I've spell checked the cards and removed incorrect past pieces. The price for the set is £20/($30). 

h2. Dos and Don'ts of usage

h4. 1. Study everyday

ANKI also requires a continued committment. You cannot do it one day and then drop it the next day. Instead daily repetition is necessary, else you will owe revisision and have to do double the following day. In some ways this is an advantages is disguise - by encouraging you to study daily you will move mountains after a year of daily work.

h4. 2. Refactor your deck

Your decks can get ugly. You might have cards on an outdated version of an API (e.g. Rails 2), incorrect facts, or knowledge you later deem unworthy of retaining. Immediatley correct these errors by deleting or modifiying the cards in question. Other good refactors are rewording difficult to remember facts or splitting them into multiple cards. A personal favourite is to find and record links between facts. If you find a parallel function in coffeescript and Ruby make a note on both cards about how it's the Ruby equivalent of map.

h4. 3. One item of knowledge per card

If you want to remember a core function in Ruby you'll need a number of cards, e.g. what does link_to do? what does it return? how do I get link-to to have a custom css class? My preffered method is short questions and answers, or sometimes missing word questions. Never EVER have answers that are large blocks of text. Refer to this article on the super memo website.

h4. 4. Try out code before entering it into cards

You should always try out code in a console before adding it to your deck. Trying out code will reveal a few things. Firstly it will alert you of any mistakes in the flash cards you are adding. It would be wasteful to learn off incorrect information. Secondly it alerts you of gaps in your understanding. You might you truly understand what you are learning when you enter it into your deck, so a real world sanity-check is important to get a feel for what you are doing.

In particular learning things like VIM shortcuts, or mac keyboard shortcuts rely on motor movemnts. I recommend switching to the editor and trying each command out for the first few reviews.

h4. 5. Take it slow

Due to how the repetitions are front loaded, trying to learn 100 new facts a day will quickly lead to you having 500 review per morning. not only will could this take an hour to do (initially reviews will be slow, but you will speed up with time) but it might sap your motivation and cause you to ditch the effort. Because of this I recommend you limit the number of new cards you learn per day to 20-40. It's about stamina, not spriing. Do not forget this. 

h4. 7. Turn every fuck-up into a lesson

Making a mistake once is human. Making the same mistake twice is unacceptable. If you do something wrong pull out ANKI and make a few cards and sit and repent.

h4. 6. Reflect and look for higher order lessons

After a large project, like building an app for a client, take some time to think about what went well and what didn't from a high level. Did the architecture make sense? Did you use source control correctly? How did you handle the relationship? What would you do differently? Regularly reflecting on the big questions will help you even more that focusing on individual functions.


