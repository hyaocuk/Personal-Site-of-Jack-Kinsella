---
layout: post
title: Janki Method: SRS and Programming
subtitle: Using Spaced Repetition Systems In Programming
author: Jack Kinsella

---

h2. The Janki Method 

This is a guide for becoming a productive programmer in as fast a time as possible. Malcolm Gladwell might have told you it takes 10,000 hours to acquire a skill; this may be true for those practicing grope learning, learning in the dark without an effective knowledge and memory management system. Surely 10,000 hours cannot be a constant. Surely there are faster routes to mastery. This is my take on cutting down Malcolm's 10,000 by basing my efforts on the science of memory and skill retention. In this guide I've distilled the process I used to learn the Ruby on Rails web development stack over a 12 month period. I had no real previous experience programming, having studied law at college. A year and a half later, not only can I rapidly build web applications, but I also own a completely automated web business which made over $30k last year, and have a number of clients who pay me senior software engineer rates for my time. I believe that any reasonably intelligent and disciplined person can achieve the same thing in as short or shorter a time-frame through the application of my system, Jack's Anki Method (Janki Method).

h2. The Four Problems In Learning

Janki method evolved to solve four problems I perceived in my own learning and skill acquisition. 

h3. The Wholly Bucket 

The Janki method began it's life as my response to my dissatisfaction with my memory. I always reasoned well with the facts at my disposal. The problem was that I didn't always have the correct facts, since knowledge painfully acquired mere months earlier would quickly slip from memory. I needed to reference the original material again and again, and relearn the same techniques over and over. My mind was wholly bucket and my knowledge was the liquid dripping out from under.

My solution to the wholly bucket problem was this: every time I learned anything about programing, I would create a flash card and add it to a memory management program named Anki. From then on, I drilled myself daily with the cards Anki's algorithm determined as most in need of review. I reasoned that doing so would guarantee a minimal base of important knowledge as far into the future as I continued my reviews.

h3. Skill Binging

Ever decide to learn guitar, spend a few hundred bucks on a limited edition, practice like crazy for two weeks, make less progress than you anticipated, get pissed off and then shamefully throw the guitar in the back of a cupboard and dodge away from question from friends and family about how guitar was going? I have, again and again, and it sucks. I call this skill binging, the belief that you can learn a complex new skill through a condensed burst of activity. Real skill acquisition occurs through long term daily efforts. Face it: it is better to spend 20 minutes learning something every day for a year than to spend ten hours learning something every day for a week. 

To solve the problem of skill binging you need to commit to a daily Janki regime. Make a daily habit of reviewing your cards. Every morning,when your mind is at it's freshest, spend ten minutes with Anki reviewing your knowledge. Throughout your day add all new knowledge to your Anki deck and continue doing this every day, for a year and you will move mountains. 

h3. The Chasm Between 'Knowing' And Doing 

Janki method requires that you try out any piece of knowledge before adding it your deck. If you learn a new function you should try it out in the console.  If you learn a new keyboard shortcut you should press it a few times. Whenever you add something to your deck without trying it out first you distance yourself from reality. There is a chasm between reading something, and being able to apply it. Perhaps the author of the blog you read assumed you had a certain configuration. Without trying to use the fact you will never realize your omission, and so your knowledge will be impotent. Similarly you might read outdated documentation, and without applying it you will accidentally commit stale knowledge to memory. Trying things out ties your knowledge reality and forces you to have a complete understanding.

h3. GroundHog Day 

The only truly stupid thing you can do is repeat the same mistake twice. t was Groundhog Day, only I was dating the books.

h2. What is Anki?

Anki is a multi-platform flash card program available for free download on every device you can think of. You begin by creating a deck, say "Computer Science". A deck contains many facts, facts being a question and a corresponding answer. You can tag these facts, (question answer pairs) with the names of the categories they belong to, for example a fact might be categorised under 'rails', 'git', or 'javascript', or perhaps even all three at once.

3 x Examples

If all Anki did was let you categorize your knowledge it would, at best, be a tool for recording and accessing old insights. But Anki doesn't stop here. Every morning, it's algorithm works which facts you need to review that day. This is calculated using the Supermemo algorithm, an algorithm invented by PIOR. Most algorithms make computers efficient; this algorithm makes you efficient. It was designed to have you drill the cards the minimum number of times necessary throughout your life whilst retaining permanent memory. It works exceedingly well.

The algorithm requires that you review new material 1 day after originally learning it, then a week later, then a month, then 3 months later, then a year later and so on. RESEARCH (how many reps in life). If you review a previously learned fact but fail to remember it, then that fact will beconsidered new material once again, and it must start the cycle at one day again. 

Every day you must do your morning Ankis. You will be presented with the question, and the answer will be blocked out. You must answer in your head, then press the enter key to have the answer revealed. At the bottom of the screen will be four buttons: again, good, easy and very easy. Use these to honestly assess how easy the recall was. Again means you couldn't remember it at all, and the others represent the ease and speed with which you could make the recall. Your self evaluation is important as the algorithm will modify the number of days until your next review of that card based on how well you say you know the fact. The onus is on you to be truthful.

eXample of question

If you get a card wrong frequently Anki will classify it as a leech and suspend it from your deck. The reasoning here is that certain cards are time leeches, as they frequently trip you up and prevent you from using your time efficiently. I view leeches as indicators of a poor question-answer pair. Am I putting too much in one card? Would a mnemomic make the fact easier to remember? Is this worth memorising at all?

The hardest part of the Janki method is not adding or finding facts; nor is it reviewing. The real difficulty is in doing it every day, for months or years on end. The JAnki method requires you drill your cards for ten minutes every morning. Failure to do so invalides the method completely and you should not expect any results.


h2. Second Order Advantages Of Using Anki 

h3. 1. Reduce Repeat Error

The only truly stupidity is repeating your mistakes twice. You must learn. You already know this. What you mightn't have though about is the number of failure reptitions it takes you to figure out why sometthin

Furthermore, constant reminder of past errors will cause you to start seeing patterns and classes of mistakes, and you will form a new mental schema of understanding.

h3. 2. Retain Memory of Unused Tools

Have you ever learned a technology, switch to something else for a few months, then come back to the original technology having forgotten close to everything you were supposed to know? I have, repeatedly. I've heard that your brain never really forgets anything, and so that knowledge is supposed to reside somewhere deep inside , but for my use case as a professional, that knowledge is no longer with me and so I need to relearn it. This is a massive waste of time.

One of the key premises to Spaced Repetition Systems, like Anki, is that knowledge entered into the system and regaularly reviewed will enver leave your memory. I've foudn this claim to be true and if quizzed on the contents of my 5500 card Anki deck I'm confident I can recall 95% accurately. 

h3. 3. Program Faster

Will having a complete picture of the API in your head make you a faster programmer? Absolutely. You'll save a ton of time you'd otherwise spend re-referring to documentaiton and other reference material. You'll read other people's code as fluently as natural language, and you'll spend your days in the console. Is this the main way the Janki method increases your productivity? 

Absolutely not.  As I developed the Janki method I noticed that it helped me program faster for different reasons. Having an in depth knowledge of APIs within your mind helps you most in debugging. Debugging is the act of isolating the problematic line of code and identifying why the problem occurred, the creating a fix that doesn't upset the rest of the code. Having a confident understanding of built-in fucntions and their uses means you only have to look up the custom function to figure out the debugging.

Another way Janki methods helps you program faster is brainstorming alternatives. An effect I noticed with Anki generally is that is reduces your recall time. The knowledge is literally at your fingertips (I found this especially when using ANKI with Spanish vocabulary. I could think of words instantly, whereas without ANKI it took strain). Say your boss asks your what the possible solutions are to a hard technical problem. Having so much knowledge at your fingertips lets you design alternatives on paper rapidly, realisticaly thinking through and evaluating the consequences. If you know what types a function expects, what it returns and where it can be used, then you can practically code in your head.

Yes, you might say that you would get the same benefits from deep knowledge of APIs gained through years of experience. That's true but it misses the point of the Janki method - you'll gain that knowledge far more rapidly and retain it for much longer using Anki.

h3. 4. Design Away From Your Machine

Complete knowledge of the API means you can design your app from a coffeeshop with nothing but a pen and few sheets of paper. You spend too much time in front of the computer - give your eyes, fingers and back a break by getting away once in a while.

h3. 5. Inspiration

The thought collision theory of creativity says we create new ideas by combining two old ideas together. Due to how Anki requires you to review your cards, the facts are essentially jumbled - both in their order and chronologically. I frequently found that cycling through my cards in the morning would set off the spark in my head I needed to solve the problem of the day. 

h3. 6. Build a deeper understanding of your domain 

As my use of Anki grew I began to refactor my decks. I'd see that collections of previous cards could be summed up a single higher level rule. I'd notice relationships between functions in different programming languages and scribble a note on a card to help aid memory by cementing the connection. By forming connections you create multiple paths to the same point of knowledge. If one path were to fail you can still trigger the knowledge through another route.

h3. 7. Have a Definitive Searchable Reference of All Your Programming Knowledge

Have you ever had a nasty bug pop up and have vague memories of having seen it before, yet you don't remember exactly how you fixed it? Before I started using Anki this happenend to me frequently. I would spend half a day solving the bug, forget about it, then six months later I'd face it again. This wasn't acceptable - I wanted to only ahave to solve a particular problem once. Luckily the Janki method enables you to do this. ANKI has a built in search where you find any fact containing a particular word. You can even filter by date or tags. After every nasty bug you should add a few cards to ANKI containing the knolwedge you need to prevent that bug from occurring again. Better yet abstract one level and add a card containing the knowledge needed to prevent that class of bugs from occurring again.

h3. 8. Feel Like You Are Making Progress

Let's face it. Technology sometimes makes you feel like you are in a rut; there's always more to learn. There's always a stack of books you want to read and learn from. Sometimes you feel like you are at the bottom of a hill. Anki makes you feel better about yourself. You browse through your deck and see the thousands of lessons you've learned. You see the variety of technologies you've learned. You see yourself, months or years ago, typing in those facts. Anki encourages you to sit back and admire the hard work you've put in.

On another level there is something satisying about working on a goal everyday. By reviewing your cards daily you are maintaining your skillset and knowledge, spending perhaps only 5 minutse of your day. You are doing something to sharpen and improve your skills. Like running every day you see results build up day-by-day.

h3. 9. Impress Interviewers

So you didn't study CS at Stanford. Problem? Definitely. How do you convince discerning companies that despite being self taught you skill have the skills they want? Showing them 5500 flash cards of lessons learned through application of their technology stack will help you prove to them that you know what you are doing. 

h2. Objections to the Janki method 

h3. 1. The best way to learn something is by doing.

I'd like to separate the idea of learning by doing into two components: discovery through doing, and learning from mistakes.

Discovery through doing is unearthing the hidden gaps in your knowledge as you attempt to apply in real world scenarios. You read a book on Javascript, feel confident you know it, only to later find out that the code you write from memory doesn't work. What happening here is that there are gaps in your knowledge traceable to you having only seen the knowledge in a sterile book environment instead of having to apply it in real world situations. It is for this reason that the Janki method makes it vital to field test all knowledge before adding it your deck. You simply cannot be expect to learn in sufficiently accurate detail just by reading. Thus Janki really is a method of learning by doing.

The second component of learning by doing is learning from mistakes. You make a major mistake, perhaps pushing unfinished code to your live server. Your mistake costs your company, and you feel stupid and embarrassed. The emotional punishment you feel serves as a strong reminder of your error and you are unlikely to need Anki to learn from these major mistakes. Where Anki is useful is for the lesser errors, where the emotional element is diminished or absent. I've found that it's only after these mistakes happen 3 times in the real world that I learn not to make the mistake again.  

The Janki method doesn't say you shouldn't learn by doing. Instead it requires it. The difference is that Janki method wants you to make the mistake only once it the real world, and then to do a post mortem on every mistake and try and discern the lessons present, creating cards out of what you've learned. You substitute real world errors with lessons in Anki, and so learn from your mistakes more quickly, and with much less real world damage and embarrassment. Not only this, but the act of recording your mistakes and trying to discern lessons from them will make you a more critical and aware programmer.

h3. 2. I don't have time.

Anki requires your enter facts into Anki, recording your mistakes and new knowledge as both occur to you during your work. You will also need to find time to review your cards - the day you create them, a week later, a month after that, three months after that, a year after that, and so on. There is a cost to placing facts in your long term memory.

To this I counter that learning to program is going to take you a long time no matter what, and, assuming you are willing to make the sacrifice, by following Janki method you will save time in the long run through solving the four problems of learning mentioned above. Not only that but you will benefit from the secondary advantages of ANKI method, such as increased programming speed, improved domain understanding, and enhanced debugging skills. Having a searchable repository of useful APIS and fixes for past bugs may save many hours of time. If you are serious about building software, and foresee yourself doing this for at least the medium-term future, using the Janki method is one of the greatest investments you can make in yourself. 

h3. 3. Knowing lots of facts or APIS doesn't make you a better coder.

This was a major concern for me when I initially began my experiment. The limiting factor to your coding productiviity surely isn't your need to consult documentaiton once in a while is it? Yea I might have 30 minutes a day in documentation look-ups and context switching, but that's no biggy right? At best the flash card system will prevent me from forgetting the API when I take a few months off to do something different.

What I've learned is that knowing the APIs gives subtler, but important advantages:

# If you use a high level language like Ruby many algorithms are already baked into the language. You want to sort an array? Array#sort does the trick. By rolling your own sort algorithm you risk making mistakes, miss out on binary level optimisations, and alienate future users of your code, who might think there was a reason you wrote a custom algorithm instead of using the built-ins. By filling your Anki deck with built-ins from your chosen languages you will only extend the language instead of reinvent it's features.

# Debugging becomes dramatically easier. Imagine you are debugging a large third party library. The code will be filled with a combination of their custom functions and functions built into Ruby itself. You will need to figure out what their custom functions do by referencing their documentation, carrying out experiments, or using the debugger. If you recognize all the built-in functions, and know precisely and with total confidence what their expected input and output values are, the only unknowns will b the third party code, and so you will be able to pinpoint errors much more quickly. 

# Chunking. Your skill in any field is the product of your intelligence and your knoweledge. These two can be substituted to some extent. If you are highly intelligent you might be will perform above what's expected for someone of your experience. Likewise, if you have a great deal of experience you may perform at a higher level than your intelligence would suggest you are capable of.  Intelligence is the application of your reasoning skills to your knowledge. It's goal is to generate new knowledge, perhaps so as to make a decision. Let's take an example. What's 13 multiplied by 3? To come up with the answer you apply your knowledge and your logic. You know that multiplication is repeated addition, and the rules of addition to arrive at the answer 39. Or maybe you didn't. Mabye you already remember that 13*3 is 39. In which case you arrived at the same answer more quickly. Taking it a step further what's 130 * 30? Using intelligence alone this becomes complex. But how can we simplify the problem using knowledge? I know that:
a) 13 * 3 = 39
b) Multiplicaiotn is commutive. Thus 130 * 30 = 13 * 3 * 100
c) x * 100 = x with two zeroes at the end

Using these points of knowledge the calcuation becomes simple: 100 multiple by 130 = 13000

Using Anki to reinforce your knowledge brings similar speed advantages to programming. By building a reposititory of knowledge you will think in higher order chunks and be able to solve more difficult problems by applying a mixture of your intelligence and your knowledge. 

h3. 4. APIS and Libraries change and so your hard earned knowledge will become obsolete.

This can be an issue, depending on how you use the Anki. When I first began the Janki method I was over-zealous in my addition of facts to my decks. In particular, I added many facts for gems (third party code plug in pieces of code for Ruby). I would turn README's into documenation out of habit. This turned out to be wasteful since the in-vogue library would change every few months and I ended up deleting many of these cards.

It's not always easy to distinguish between knowledge worth keeping long term, and knowledge which you will only need in the short term. Long term knowledge is best entered into ANKI, whilst short term knowledge needs only to be referred to in the momement.

My current thinking is that the following areas have long term value and belong in you decks: unix command line, refactoring, design patterns, git, regular expressions, ruby, object orientated programming principles, functional programming principles, Javascript, http protocol, sql, css, html, VIM commands, rails, and jquery methods. I noticed some patterns in what proves to be useful knowledge:
a) It's a technology that's been around for a long time, and it probably here to stay (VIM, linux, Ruby, Javascript)
b) It's general wisdom about computer science (refactoring, regular expressions, object orientated programming and so on)
c) It's something that whilst new or a library, is in everyday use and will foreseeably be so for some time (rails, git, jquery). 

I'm sure that one day I'll be replacing my rails cards with the next-big-thing but I justify the continued presence of Rails cards in my deck by the size of the library, the productivity value of the knowledge, the market value of the skills, and the value of having cards about *a* web framework,  since many of the concepts and terminology learned here will be valuable in parallel web frameworks, whatever they might look like.


h2. Appendix


h3. Where do I get decks to review? Should I download other people's decks? 

Anki has a built in searchable database of other people's decks of cards. You may be tempted to download and compile the decks of others in order to save time creating your own decks. Using other people's decks instead of creating your own is a bad idea. Initially I attempted this but it turned out to be a waste time. You will add facts which are of no particular use to you simply because they were included in the other deck and so you presumed they must be important. You will inherit the mistakes of the original author. The question and answer format may work for the original author, but will not be in your own. You will be tempted to review and learn facts which you do not fully understand, and will succumb to that temptation. Do not do this.

Instead you must create you own decks, drawing from your daily experiences programming, reading textbooks, APIS, and snippets of interesting code, watching screencasts, reading insightful blog posts, working with other programmers, reading documentation for key libraries, solving bugs, and, most importantly of all, reviewing and learning from the mistakes you make in your own work. This active process ensures your deck will be filled with practical and real world knowledge, applicable to your circumstances, phrased appropriately for your mind, categorised in a way that makes sense to you, and fully understood by you.

h3. Can I Download Your Deck? 

I don't recommend using other people's decks as the basis for your own, but I understand that seeing a full deck will help you understand the format of the questions and let you reverse engineer a process.  I've made my deck available for free download at my startup "Oxbridge Notes":http://www.oxbridgenotes.co.uk. The deck deals with Ruby and rails 3.1 in detail, and includes sections on everything from design patterns, to refactoring, to the HTTP protocol, CSS, javascript, VIM, rspec, capybara, coffeescript, jquery, deployment issues. It's everything I've needed to know to build, manage and deploy a variety of apps using the Rails stack. This isn't a commercial product, so expect some mistakes, and inaccurate tagging. If you download the deck please link to the download page in some way, for example by mentioning it on your blog, or marking it in Delicicious. And please don't upload my deck elsewhere online.

h3. What are the main keyboard shortcuts I need to know.

For speedy reviews hit <enter> to reveal answers and then evaluate your response with 0,1,2 or 3. Command + E lets you edit a given card, Command + <backspace> lets you delete a troublesome/incorrect/out of date card.

h3. What You Need To Know To Build Web Applications

I choose to learn to develop using Ruby on Rails, having heard that the Rails was the cutting edge in web application development and the most productive technology currently available. Soon after I began, I realized that I Rails was only one element in a much larger stack of technologies and necessary skills. In order to be able to produce, deploy and manage a web business, you need the following skills:

# Ruby Rails, Git, unix command line, Javascript, jQuery, object orientated programming, regular expressions, CSS, HTML, refactoring, design patterns, server-administration and deployment, the VIM text editor, SQL, Test Driven Development (integration and unit tests), debugging and the HTTP protocol. 

h2. Dos and Dont's of usage

h4. 1. Study everyday

You must commit to Janki method everyday - and that includes weekends, and holidays. You will not get optimal results if you apply it inconsistently. In particular you must never miss a day of reviews. 

h4. 2. Refactor your deck

Your decks can get ugly. You might have cards on an outdated version of an API (e.g. Rails 2), incorrect facts, or knowledge you later deem unworthy of retaining. Immediatley correct these errors by deleting or modifiying the cards in question. Other good refactors are rewording difficult to remember facts or splitting them into multiple cards. Another good refactor is to find and record links between facts. If you find a parallel function in Javascript and Ruby make a note on both cards about the connection. Forming these links helps you think at a higher level.

h4. 3. One item of knowledge per card

If you want to remember a core function in Ruby you'll need a number of cards. Say you are studying the function "link_to", which generates a hyperlink in your web app. One card will ask what does link_to do? Another will ask what does it return? Another will tell you how to get link_to a custom css class? My preferred method is short questions and answers. Never EVER have answers that are large blocks of text. Refer to this article on the super memo website for more on creating good questions and answers.

h4. 4. Try out code before entering it into cards

You should always try out code in a console before adding it to your deck. Trying out code will reveal a few things. Firstly it will alert you of any mistakes in the flash cards you are adding. It would be wasteful to learn off incorrect information. Secondly it alerts you of gaps in your understanding. You might you truly understand what you are learning when you enter it into your deck, so a real world sanity-check is important to get a feel for what you are doing.

In particular learning things like VIM shortcuts, or mac keyboard shortcuts rely on motor movemnts. I recommend switching to the editor and trying each command out for the first few reviews.

h4. 5. Take it slow

Due to how the repetitions are front loaded, trying to learn 100 new facts a day will quickly lead to you having 500 review per morning. not only will could this take an hour to do (initially reviews will be slow, but you will speed up with time) but it might sap your motivation and cause you to ditch the effort. Because of this I recommend you limit the number of new cards you learn per day to 20-40. It's about stamina, not spriing. Do not forget this. 

h4. 7. Turn every fuck-up into a lesson

Making a mistake once is human. Making the same mistake twice is unacceptable. If you do something wrong pull out Anki and make a few cards and sit and repent.

h4. 6. Reflect and look for higher order lessons

After a large project, like building an app for a client, take some time to think about what went well and what didn't from a high level. Did the architecture make sense? Did you use source control correctly? How did you handle the relationship? What would you do differently? Regularly reflecting on the big questions will help you even more that focusing on individual functions.

h3. Conclusions

If you enjoyed this post please mention it on your blog, and if you'd like to comment please do so on Hacker News. Also I'm visiting San Fran from now until Xmas 2011 so send me a message if you'd like to lunch/coffee/beer.

