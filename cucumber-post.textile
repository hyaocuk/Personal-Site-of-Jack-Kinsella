Cucumber: The Wrong Tool For Almost Every Job

I recently heard an account of how a web development gig went from the points of view of both the consultancy and the client. Talking with the designer at the consultancy, he told me about how his company doesn't compromise on what they know is right. During their latest gig they educated a reluctant client and him to do things the Right Way. The designer reasoned that although acting this way may hurt the consultancy in the near future, with time they will be recognised for providing long term value. According to him, the client liked them, and the gig went especially well. 

A few days later I bumped into the client and inquired about their recent development work. 

"Never again. [They ] were a nightmare to deal with. They wouldn't listen to what I wanted, and wasted my time with things I didn't care about. In fairness they did good technical work. But, my god, they had absolutely no business sense. I mean all I wanted was a website*."

* It was a web app, but lots of people don't distinguish between the two.

This is an essay about how Cucumber is the wrong tool for almost every job. I'm going to look at the advantages and disadvantages to using Cucumber, compare this with real world usage, and then draw up a schema for when Cucumber is justified as opposed to when its use it is outright unforgivable. And, in case you are wondering, thsi is an opinion informed by experience: I've used Cucumber in six projects, as a lone developer, a collaborator on a larger team and as a client of programming services. 

h2. The Advantages of Cucumber

The alleged advantages of Cucumber is well trodden territory so I'll just give a summary of the most commonly cited arguments in Cucumber's favour:

# Cucumber is in plain language so non-technical stake holders can read them and maybe even write them.
# Cucumber forces you to slow down and think about the value a feature brings before delving into implementation.
# Cucumber is high level documentation.
# Cucumber, with its high level descriptors and understandable web steps, makes testing less scary for developers beginning automated testing.
# Cucumber is language agnostic and therefore is ideal is hyper-polyglot projects.

[references]

h2. The Disadvantages of Cucumber

There has not been enough thought on the downsides of using Cucumber and so I'm going to get into some detail here. I'm comparing Cucumber to old fashioned integration tests, or request specs if your prefer RSPEC.

h3. 1. Cucumber breaks text editors

Text editors, like VIM, multiple productivity. Auto-completion ease the use of long, descriptive method names as we no longer need to type them in full or remember their signature precisely. Compilation checks prior to saving catch many syntax errors before they cause harm. Our text editors reduce errors we introduce through typo, forgetfulness, or sloppiness.

Cucumber's steps are method names in Gherkin syntax. Some argue that these steps aren't code, for example when a declarative style is used which omits the use of any paramters. This is rreleavant here because, whatever you want to call the step definitions, they still break our text editors because they contain white space, include their parameters at non-standard locations (When “john@gmail.com” has “4” unsent messages), and use regular expressions for pattern dispatch ("and|or"). Our editors are not adapted to deal with this syntax and so autocomplete, search and other features break down, slowing productivity.

h3. 2. Cucumber requires maintainenance of parallel worlds

I'm assuming that anyone thinking of using Cucumber already tests their models using something like Test::Unit or Rspec. Both of these libraries require you to set up a separate environment, their own worlds if you will.  We organise and manage increasingly complicated test suites by placing shared test code into helper methods shared across tests and categorising our tests using tagging systems. We use tools like Spork to speed up our tests, or watchr to run them automatically. We add Gems to gain access to helper methods which aid in testing key areas, perhaps freezing time, reading emails, or faking web requests. 

Cucumber doesn't like to share. It does not automatically use many of our exsting test configurations and helper methods. Our taxonomy of tags carry no weight we must mirror the system without cucumber. We set up Cucumber separately, often duplicating code, and always increasing complexity and thus scope for error. These parallel worlds must be maintained by the project owner, and creators of testing gems must now cater for two masters. Cucumber takes another toll.

h3. 3. Cucumber's routing causes you cognitive strain 

Cognitive strain is the otal weight of facts and rules we must hold in our minds to be productive using a technology. Rails strains; When I began using Rails four years ago I faced an extended period of difficulty as I acclimatized to the labyrinthine naming patterns of routes, rules about what does and does not get pluralized, and subtle distinctions between various ActiveRecord::Base persistence methods. Strain is sometimes necessary to enable us to operate powerful tools, but all things equal, less strain for equal power is a good thing.

When testing Rails application using Cucumber the mention of a certain web page, for example "the login page", requires us to map this natural language descript to a more technical description. Here's a reminder:

[test that it won't pick up someting like this]
    when /the login page/  
       login_path

Cucumber adds an abstraction layer over Rails routes, an area which already congitively strains. This led to pain and error on larger projects. As I added new features I presumed I would unintentionally describe some routes with numberous natural language descriptions. Perhaps I'd call "the login page" the "the sign in page" one day, and "the log in page" another. When I did this, Cucumber complained that it could not find the permuted path and so I had to look inside the paths.rb file to remind myself of my previous phrasing, then return to the step definition and fill in the correct English language mapping of the route helper mapping to the actual url. That's a lot of mental mapping, and a lot of room for error.

I've experimented with removing the paths.rb file are automagically determining the route, but this ends up either turning the language of your Cuke into unacceptable steps such as "And then I am on the new user session page" or, if you want to preserve the non-techncial communicative dimension of Cucumber, then you'll need unacceptably complex logic. By defintion, paths.rb is a necessary part of Cuking It Right.

h3. 4. Cucumber's organisation defaults are impractical 

My favorite feature of Rails, is one of its simplest: everything has its right place. Mailers go in one folder, models go in another and configurations go somewhere else else. Presuming that a project sticks to convention, you can find the source code for any function effortlessly. This brings enormous productivity advantages.

If you Cuke correctly (Jonas link), you've write your steps in declarative style step definitions, written using the language of the stake-holder, word that he can understand. This means, amongst other things, that you don't use hash tables of model attributes in your scenarios, or css selectors or any other technical details,

[check convention]
Upon running these files Cucumber will ask you to create step definitions. Cucumber’s convention is to keep these steps in a file with the pattern FEATURE_NAME_steps.rb. The step definitions are trivial to find; that is until you begin reusing your step definitions so as to get your testing code DRY. Say you write a feature which promotes a post on the homepage . You will place your step definition for “Given I promote a post” in promote_posts_feature_steps. Twenty six weeks later you are writing another feature connected to promoting posts, and you'd like to reuse the step. I’ve found two things tend to happen in this scenario: 

In the happier scenario I remember the original method exists, look up it’s name and reuse it. Ideally I abstract it to a global helper, rather than leave it in the promote_posts_feature_steps.rb, since its position there suggests exclusive connection with that feature, when this is no longer true. The difficulty here is that now you need to thematically separate shared step definitions into files. This is harder than it sounds; as the conceptual barriers in integration tests are blurred. If I were to use Cucumber again, I’d like to try one big file. Not pretty, but solvable. Now for the unhappy route.

I might have forgotten that I previously wrote a step definition for promoting a post (or not seen that another programmer had done so), and so I repeat the knowledge of do so in the taxon_steps.rb, My code is no longer DRY and if I forget to refactor one version I will cause confusing test failures. Cucumber’s default way of organising features sets you up for these difficulties.

h3. 5. Increased Wordiness

Brevity is the sole of wit. If you are using Ruby, Clojure, CoffeeScript, or Haskell you surely know this. Yet, you use Cucumber to write method names with two or three times as many characters as theire plainer Capybara equivalents. Compare:

Given I am on the home page #27 characters
visit root_path #15 characters

Increased wordiness reduces expressiveness and power, and introduces error on the basis that there more characters typed is more places a typo can seep in. Yes this is necessary for non techncial communication, but remember we're talking about the disadvantages here.

h4. 6. Cucumber syntactically discourages simple code reuse.

Cucumber users tend to write their step definition in terms of other step definitions.  The library creators have implicitly encouraged this by creating ever simpler means for doing so, culminating in the current steps function:

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
  steps %Q{
    When I am on the last upload page for “#{product_name}”
    And I follow "full_samples"
    And I press "toggle_full_sample"
    When I refresh the page
  }
end

This is an abomination. Why? For one you get all the disadvantages of Cucumber with none of its advantages. You have increased wordiness and thus higher error rates, your editor breaks, your method names are difficult, or impossible to remember, and your tests run more slowly. Worst of all, unless you are disciplined in refactoring, your original step definitions for the nested step will remain, say in the uploads_steps.rb file. This is problematic because it’s use outside of uploads.feature is not expected, and so the definition may get deleted when someone on the project scraps the uploads feature. To avoid this the reused step definition should be moved to clearly marked global helper step files immediately after resue. But even if you are disciplined and careful enough to do this, you still suffer the penalties of Cucumber’s syntax despite there being no non technical stake holder who will ever read this code. 

This anti-pattern is rampant in the Rails community. Even Jonas, who otherwise Cukes It Reasonably Alright, promoted this. Luncacy. When you are in the programmer territory why wouldn't you take full advantage of the brevity, precision, composability, regularity and editor support of a full programming language? It stumps me.

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
   admin do 
        feature_latest_upload #defined as a global helper
        refresh_page
        should_see(sample_path, “features”)
    end
end

The set of features in Cucumber facilitating reuse of steps, alongside the emphasis on Cucumber’s web steps over Capbyara, to the point where the seeming majority of programmers only know of the Cucumber version, is a technical tragedy.

h2. When Should I Be Using Cucumber

We've seen that Cucumber has advantages; we've also seen that Cucumber has its disadvantages. Whether Cucumber use makes sense is context-dependent, becaues the relative weight of the advantages are higher or lower depending on the situation.

Assuming the truth of these advantages for now, we can determine a schema for helping us decide when to use Cucumber over plain
old integration tests.

|Using 3 more languages extensively? |Should I Be Cuking It?| Why? |
|You have a project with a budget under $20k | No 
|You are working alone| God no | You are technical and can read Capybara.|
|You are working on an open source project | No | Everyone is technical. |
|You ar working in an early startup| No | You are the tech department / easier to communicate with your co-founder|

This logic suggests five rules about sensible usage:


The problem is we aren't following these sensible rules.

Research:

h2. What clients want

In my experience, your average small client cares about only one acceptance test criteria. I'm going to write this in Gherkin for you:

feature: As a manager of some sort 
         In order to get on with my job
         I want the goddamn thing to work

scenario:It does what its supposed to
         [Given omitted.  Normal people don't think about state. They think about cause and effect.]
         When someone uses it
         Then it* works

I put an asterisk beside "it" to signal reference to the totality of features you'd previously agreed to - whether that was explicitly through a spec document, exchanged emails, and conversations, or implicitly, in the sense of reasonable expectations, such as 'all websites I've ever seen do that so mine ought to too'. Telling a user that they got their email/password combon is en example of this.

In my experience as a consumer and producer of development services, these features are documented somewhere outside the code, either in an Excel sheet or on something like Pivotal Tracker, typically stored on a convenient single page.

h2. The Costs Of Cucumber

h3. 1. Cucumber breaks your editor

Text editors, like VIM, multiple our productivity. Auto-completion lets us use long, descriptive Code Complete friendly method names without the need to type the name in full or remember precisely. Compilation upon saving catches most syntax errors before they cause harm. Our text editors reduce errors we introduce through typo, forgetfulness, or sloppiness.

Cucumber's steps are simply method names in Gherkin syntax. You might argue that whilst Cucumber steps are usually code with an awkward syntax, the setps needn’t be code in the hands of a programmer smart enough to use Cucumber as as it was intended. Maybe so,  but whatever the steps might be, they still break our text editor . Gherkin method names contain white space, include their parameters at non-standard locations (When “john@gmail.com” has “4” unsent messages), and use regular expressions for patten dispatch ("and|or"). Modern editor's cannot handle this syntax and so these features break down. Productivity is crippled and error soars. 

h3. 2. Cucumber requires you to maintain parallel worlds

Good Rails programming practice demands we write unit tests for custom public methods on our models We most commonly write these in Test::Unit or RSpec. We refactor growing test suites by pushing shared test code into helper methods which we share with other tests. Since it can take 30 seconds or more to start a test suite from cold, many use Spork to cut the wait. We add Gems to ease testing in certain areas, many use email_spec to simplifying tests on emails. On big projects we categorise our tests using tags, perhaps to separate slow tests from fast tests. 

Not only do we maintain a cleanly factored code base, alongside its dependencies, but we also manage an environment for out test suite.

Cucumber doesn't like to share. It does not use our existing test configurations and helper methods. Our taxonomy of tags carry no weight. We have to set up Cucumber separately, sometimes duplicating code, and always increasing complexity and scope for error. This parallel worlds must be maintained, costing time and effort. Creators of gems which aid our ability to test must cater for two masters. Cucumber takes another toll.

h3. 3 Cucumber's routing causes you cognitive strain

Cognitive strain here refers to the total weight of facts and rules we must hold in our minds to be productive using a given technology. Rails requires much of us already; All beginners face an initial period of difficulty as they acclimatize to the  labyrinthine naming patterns of routes, the rules about what does and does not get pluralized, and the subtle distinctions between ActiveRecord::Base persistence methods. Less cognitive strain is a basic good.

In default Cucumber usage the mention of a certain web page, for example the login path, requires us to map our natural language description to our technical description, generally done with Rail’s baked in URL helpers.:

    when /the seller's overview page/  
        "/admin/sellers"

Due to this added abstraction my productivity dropped. Frequently when I added new features I unintentionally described a page with different natural language, perhaps I might call "the login page" the "the sign in page" or "the log in page". Cucumber complained that it could not find the path and I had to look back to the paths.rb file to remind myself of my previously phrasing. For a while I was tempting to use regular expressions to match the many variations I liked to use, but I quickly stopped this in the interest of creating canonical vocabulary and keeping DRY. Adding abstraction to the already confusing route-naming system was an unwelcome strain which damaged productivity and killed enjoyment.


h3. 4. Cucumber organisation defaults are impractical 

My favorite feature of Rails, is one of its simplest:everything has a home. Mailers go in one folder, models go in another and configurations go somewhere else. Presuming that a project stuck to convention, you can find the source code for any functionality effortlessly. This brings enormous productivity advantages.

If you Cuke correctly (Jonas link), you write your steps in declarative style step definitions, written using the language of the stake-holder, word that he can understand. Jonas says that the only use of Pickle is to land you in one, and, carrying Jonas’s logic to its natural conclusion, one he oddly never let himself arrive at, web steps.rb should be immediately deleted. Using Cucumber this way requires you keep a mapping of your abstract definitions to their implementing code. 

Cucumber’s generated convention is to keep these steps in a file with the pattern FEATURE_NAME_steps.rb. The step definitions are trivial to find; that is until you begin reusing your steps to keep DRY. Say you write a feature which promotes a some content on the homepage . You’ll be prompted to define “Given I promote a post” in promote_posts_feature_steps. Twenty six weeks later you are writing a taxon feature and that depends on having a promoted post. I’ve found two things tend to happen. 

In the happier scenario I remember the original method exists, look up it’s name and reuse it. Ideally I abstract it to a global helper, rather than leave it in the promote_posts_feature_steps.rb, since its position there suggests exclusive connection with that feature, when this is no longer true. The difficulty here is that now you need to thematically separate shared step definitions into files. This is harder than it sounds ; as the barriers in integration tests are difficult to call. If I were to use Cucumber again, I’d like to try one big file. Not pretty, but solvable. Now for the unhappy route.

I might have forgotten that I previously wrote a step definition for promoting a post (or not seen that another programmer had done so), and so I repeat the knowledge of do so in the taxon_steps.rb, My code is no longer DRY and if I forget to refactor one version I will cause confusing test failures. Cucumber’s default way of organising features sets you up for these difficulties.

h4. 5. Cucumber syntactically discourages simple code reuse.

Cucumber users tend to write their step definition in terms of other step definitions.  The library creators have implicitly encouraged this by creating ever simpler means for doing so, culminating in the current steps function:

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
  steps %Q{
    When I am on the last upload page for “#{product_name}”
    And I follow "full_samples"
    And I press "toggle_full_sample"
    When I refresh the page
  }
end

This is an abomination. Why? For one you get all the disadvantages of Cucumber with none of its alleged advantages. You have increased wordiness and thus higher error rates, your editor breaks, your method names are difficult, or impossible to remember, and your tests run more slowly. Worst of all, unless you are disciplined in refactoring, your original step definitions for the nested step will remain, say in the uploads_steps.rb file. This is problematic because it’s use outside of uploads.feature is not to be expected, and so the definition may get deleting if you decide to scrap the uploads feature. To avoid this the reused step definition should be moved to clearly marked global helper step files. But even if you do this, you must still suffer Cucumber’s syntax despite there being no good argument to do so,, for the implementation of the step definitions is of no interest to the stake holder.

This anti-pattern is rampant in the Rails community. Even Jonas, who otherwise seems to use Cucumber sensibly, promotes this.  I don’t see the point. When you are in the realm of the programmer why not take full advantage of the brevity, precision, composability, regularity and editor support of regular functions?  

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
   admin do 
        feature_latest_upload #defined as a global helper
        refresh_page
        should_see(sample_path, “features”)
    end
end

The set of features in Cucumber facilitating reuse of steps, alongside the emphasis on Cucumber’s web steps over Capbyara, to the point where the seeming majority of programmers only know of the Cucumber version, is a technical tragedy.

h2. The Costs Of Cucumber

h3. 1. Cucumber breaks your editor

Text editors, like VIM, multiple our productivity. Auto-completion lets us use long, descriptive Code Complete friendly method names without the need to type the name in full or remember precisely. Compilation upon saving catches most syntax errors before they cause harm. Our text editors reduce errors we introduce through typo, forgetfulness, or sloppiness.

Cucumber's steps are simply method names in Gherkin syntax. You might argue that whilst Cucumber steps are usually code with an awkward syntax, the setps needn’t be code in the hands of a programmer smart enough to use Cucumber as as it was intended. Maybe so,  but whatever the steps might be, they still break our text editor . Gherkin method names contain white space, include their parameters at non-standard locations (When “john@gmail.com” has “4” unsent messages), and use regular expressions for patten dispatch ("and|or"). Modern editor's cannot handle this syntax and so these features break down. Productivity is crippled and error soars. 

h3. 2. Cucumber requires you to maintain parallel worlds

Good Rails programming practice demands we write unit tests for custom public methods on our models We most commonly write these in Test::Unit or RSpec. We refactor growing test suites by pushing shared test code into helper methods which we share with other tests. Since it can take 30 seconds or more to start a test suite from cold, many use Spork to cut the wait. We add Gems to ease testing in certain areas, many use email_spec to simplifying tests on emails. On big projects we categorise our tests using tags, perhaps to separate slow tests from fast tests. 

Not only do we maintain a cleanly factored code base, alongside its dependencies, but we also manage an environment for out test suite.

Cucumber doesn't like to share. It does not use our existing test configurations and helper methods. Our taxonomy of tags carry no weight. We have to set up Cucumber separately, sometimes duplicating code, and always increasing complexity and scope for error. This parallel worlds must be maintained, costing time and effort. Creators of gems which aid our ability to test must cater for two masters. Cucumber takes another toll.

h3. 3 Cucumber's routing causes you cognitive strain

Cognitive strain here refers to the total weight of facts and rules we must hold in our minds to be productive using a given technology. Rails requires much of us already; All beginners face an initial period of difficulty as they acclimatize to the  labyrinthine naming patterns of routes, the rules about what does and does not get pluralized, and the subtle distinctions between ActiveRecord::Base persistence methods. Less cognitive strain is a basic good.

In default Cucumber usage the mention of a certain web page, for example the login path, requires us to map our natural language description to our technical description, generally done with Rail’s baked in URL helpers.:

    when /the seller's overview page/  
        "/admin/sellers"

Due to this added abstraction my productivity dropped. Frequently when I added new features I unintentionally described a page with different natural language, perhaps I might call "the login page" the "the sign in page" or "the log in page". Cucumber complained that it could not find the path and I had to look back to the paths.rb file to remind myself of my previously phrasing. For a while I was tempting to use regular expressions to match the many variations I liked to use, but I quickly stopped this in the interest of creating canonical vocabulary and keeping DRY. Adding abstraction to the already confusing route-naming system was an unwelcome strain which damaged productivity and killed enjoyment.


h3. 4. Cucumber organisation defaults are impractical 

My favorite feature of Rails, is one of its simplest:everything has a home. Mailers go in one folder, models go in another and configurations go somewhere else. Presuming that a project stuck to convention, you can find the source code for any functionality effortlessly. This brings enormous productivity advantages.

If you Cuke correctly (Jonas link), you write your steps in declarative style step definitions, written using the language of the stake-holder, word that he can understand. Jonas says that the only use of Pickle is to land you in one, and, carrying Jonas’s logic to its natural conclusion, one he oddly never let himself arrive at, web steps.rb should be immediately deleted. Using Cucumber this way requires you keep a mapping of your abstract definitions to their implementing code. 

Cucumber’s generated convention is to keep these steps in a file with the pattern FEATURE_NAME_steps.rb. The step definitions are trivial to find; that is until you begin reusing your steps to keep DRY. Say you write a feature which promotes a some content on the homepage . You’ll be prompted to define “Given I promote a post” in promote_posts_feature_steps. Twenty six weeks later you are writing a taxon feature and that depends on having a promoted post. I’ve found two things tend to happen. 

In the happier scenario I remember the original method exists, look up it’s name and reuse it. Ideally I abstract it to a global helper, rather than leave it in the promote_posts_feature_steps.rb, since its position there suggests exclusive connection with that feature, when this is no longer true. The difficulty here is that now you need to thematically separate shared step definitions into files. This is harder than it sounds ; as the barriers in integration tests are difficult to call. If I were to use Cucumber again, I’d like to try one big file. Not pretty, but solvable. Now for the unhappy route.

I might have forgotten that I previously wrote a step definition for promoting a post (or not seen that another programmer had done so), and so I repeat the knowledge of do so in the taxon_steps.rb, My code is no longer DRY and if I forget to refactor one version I will cause confusing test failures. Cucumber’s default way of organising features sets you up for these difficulties.

h4. 5. Cucumber syntactically discourages simple code reuse.

Cucumber users tend to write their step definition in terms of other step definitions.  The library creators have implicitly encouraged this by creating ever simpler means for doing so, culminating in the current steps function:

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
  steps %Q{
    When I am on the last upload page for “#{product_name}”
    And I follow "full_samples"
    And I press "toggle_full_sample"
    When I refresh the page
  }
end

This is an abomination. Why? For one you get all the disadvantages of Cucumber with none of its alleged advantages. You have increased wordiness and thus higher error rates, your editor breaks, your method names are difficult, or impossible to remember, and your tests run more slowly. Worst of all, unless you are disciplined in refactoring, your original step definitions for the nested step will remain, say in the uploads_steps.rb file. This is problematic because it’s use outside of uploads.feature is not to be expected, and so the definition may get deleting if you decide to scrap the uploads feature. To avoid this the reused step definition should be moved to clearly marked global helper step files. But even if you do this, you must still suffer Cucumber’s syntax despite there being no good argument to do so,, for the implementation of the step definitions is of no interest to the stake holder.

This anti-pattern is rampant in the Rails community. Even Jonas, who otherwise seems to use Cucumber sensibly, promotes this.  I don’t see the point. When you are in the realm of the programmer why not take full advantage of the brevity, precision, composability, regularity and editor support of regular functions?  

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
   admin do 
        feature_latest_upload #defined as a global helper
        refresh_page
        should_see(sample_path, “features”)
    end
end

The set of features in Cucumber facilitating reuse of steps, alongside the emphasis on Cucumber’s web steps over Capbyara, to the point where the seeming majority of programmers only know of the Cucumber version, is a technical tragedy.

H3. What are Cucumber’s advantages?

H3. Does Cucumber Deliver Its Advantages?

Opinions here may differ, but I vote a firm no.

Cucumber may be capable of plain language, but its never used this way in practice. In my work as both a producer, collaborator and purchaser of Rails development work, I have never, even once, seen Cucumber steps written in the style Jonas promotes. Since this is only anecdotal I researched six of the most popular open source Rails apps, [Spree, Refinery, Redmine, Tracks, Radian and Diaspora] of them them four employed Cucumber and all broke Jonas’s rule: “A step description should never contain regexen, CSS or XPath selectors, any kind of code or data structure. [Tracks was the best of the lot]. It should be easily understood just by reading the description.". Smells like hypocrisy to me. Either use Cucumber as its intended or bite the bullet and join me with Capybara.

#Typical Cucumber Step

 Scenario: sends an invitation
      Given a user with email "bob@bob.bob"
      When I sign in as "bob@bob.bob"
      And I follow "By email"
      And I fill in "user_email" with "alex@example.com"
      And I press "Send an invitation"
      Then I should have 1 Devise email delivery
#Stake Holder Language[quit the waffling. We’re busy]

I should be able to send invitations to my friends.

Many teams use Cucumber when there is no need for carrying the overhead of plain language communication. A solopreneur effort, or a tech startup will either have a fully technical team or close enough communication that it has no business wasting development time with Cucumber.  They say that 19/20 startups fail? Welcome to the 19.

 A consultancy where the client doesn’t read Cucumber steps is another example of wasted Cucumber. My experience makes me suspect that most clients couldn’t care less about your Cucumbers. They care about one feature: it “works  (as intended)”. As a consumer of consultancy services I never cared for reading Cucumber features (part of it was that they were written using web_steps.rb, making it unreadable and dull).  Collaborate with Pivotal Tracker, or excel. Let them tick off features as they are done. You can turn use Conextra stories within these programs if you like, and of course you will have integration tests to prevent regression each story. Sure Cucumber lets you put these Conextra stories into the code, but why repeat yourself? On the client’s tab no less.

The over supposed advantage is that cucumber lets you think about the business value of the feature before implementing it. Wait. We’ve already established that you couldn’t possibly we a tech startup. Either you are working in enterprise or working for a client, in which both cases I presume you have a boss who makes the business decisions and you implement. Soldiers don’t decide who to they fight; they fight. Let’s stop the make believe.

I get that lacking documentation is a major issue in large systems. Linus recently said that the biggest issues with linux were never technical; they were lack of documentation (and hardware manufacturers). I retort that 1) On technical teams Capybara steps are slightly easier to read,owing to precise definition and concision. 2) On non technical teams Capybara methods names, as produced say by Rspec or acking for test, is good enough documentation, and any record in specs or pivotal tracker form good extras.

In short Cucumber is often unnecessary as either the stake holders are all technical, communication is redundant due to other systems, and in the rare cases that it can be used as a communication tool, it is practically never used in a way that could offer any of the advantages to non technical stake holders.

H3. The solution

The best way to avoid the problems is not to use it. Use Test::Unit integrations tests or Rspec request specs instead. Your editor supports it, there is no parallel world to maintain nor is there an added routing abstraction to get your mind around. Since it’s just Ruby, it’s designed for code reuse. For the technical documentation is formed from the test method names by Rspec or TestUnit, and if tests as documentation is important to you then it’s hardly brainfuck:

Visit about_us_path
Click_link “buy”

Organisation of helper methods can be messy, using one big file makes sense as well. The Skinny on Cucumber: You Ain’t Going To Need It. Really. Ultimately, and perhaps most importantly is this quote from Peter Cooper on Hacker News:

“ If a particular type of testing is slowing you down or causing you to be less productive, don't do it! But stick with the tests and processes that do allow you to be quick but without abandoning testing in favor of the old "code and pray" approach.

Some people recommend Steak; don’t fall for this - it’s an unnecessary library and a technical dead end. Its author seem to be on the same track as I am but ended up sitting on the fence by trying to be both an acceptance tests and have Ruby syntax.Why not take a side, save yourself a dependency and just write old fashioned integration tests. 

Ask yourself, honestly, if the reason you've been enjoying using Cucumber is because you enjoy integration testing and working with Capybara? The answer, I suspect, is yes. See you on the bright side of the ghetto.

Addendum:

If you must use Cucumber I’ve distiled these practices:

* Share global test helper modules with Rspec to minimize code duplication
* Delete web steps.rb as soon as you install Cucumber. Learn Capybara’s API instead
* Write short, high level declarative steps. Remember your intent is in the feature files, your implementation is in step definitions. 
* Never call a step definition within another step definition. If you want to be dry, encapsulate the contents of both step definitions in a Ruby helper method and call it from both. If it makes sense to add this to you app, e.g. a model’s API, then do so.
* Use one big bag of helper methods - in Ruby not web-steps.


